<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Golang Arrays - Parish</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="Golang Arrays"><meta itemprop=description content="In Go, an array is a fixed length, ordered collection of values of the same type stored in contiguous memory locations.The number of elements is the array&rsquo;s length and it is never negative. The length of the array must always evaluate to a non-negative constant that can be represented as a value of the int data type.
In Go unlike in other imperative languages the size of the array is part of its type, which in part limits its expressive power hence you will not often use them in your programs."><meta itemprop=datePublished content="2019-05-11T16:32:44+03:00"><meta itemprop=dateModified content="2019-05-11T16:32:44+03:00"><meta itemprop=wordCount content="1164"><meta itemprop=keywords content><meta property="og:title" content="Golang Arrays"><meta property="og:description" content="In Go, an array is a fixed length, ordered collection of values of the same type stored in contiguous memory locations.The number of elements is the array&rsquo;s length and it is never negative. The length of the array must always evaluate to a non-negative constant that can be represented as a value of the int data type.
In Go unlike in other imperative languages the size of the array is part of its type, which in part limits its expressive power hence you will not often use them in your programs."><meta property="og:type" content="article"><meta property="og:url" content="https://parish.github.io/posts/golang-arrays/"><meta property="article:published_time" content="2019-05-11T16:32:44+03:00"><meta property="article:modified_time" content="2019-05-11T16:32:44+03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang Arrays"><meta name=twitter:description content="In Go, an array is a fixed length, ordered collection of values of the same type stored in contiguous memory locations.The number of elements is the array&rsquo;s length and it is never negative. The length of the array must always evaluate to a non-negative constant that can be represented as a value of the int data type.
In Go unlike in other imperative languages the size of the array is part of its type, which in part limits its expressive power hence you will not often use them in your programs."><link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://parish.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://parish.github.io/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://parish.github.io/css/dark.css><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://parish.github.io/js/main.js></script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://parish.github.io/><img src=/images/profile.jpg alt=Parish></a></div><h1 class=site-title><a href=https://parish.github.io/>Parish</a></h1><div class=site-description><p>Software Engineer. Interested in distributed systems and low level stuff. ( Golang, K8s, *nix Operating Systems )</p><nav class="nav social"><ul class=flat><li><a href=https://github.com/basebandit title=Github><i data-feather=github></i></a></li><li><a href=https://twitter.com/_mr_Parish title=Twitter><i data-feather=twitter></i></a></li><li><a href=/index.xml title=RSS><i data-feather=rss></i></a></li></ul></nav><span class=scheme-toggle><a href=# id=scheme-toggle></a></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/posts>All posts</a></li><li><a href=/about>About</a></li><li><a href=/tags>Tags</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>11</span>
<span class=rest>May 2019</span></div></div><div class=matter><h1 class=title>Golang Arrays</h1></div></div><div class=markdown><p>In Go, an array is a fixed length, ordered collection of values of the same type stored in contiguous memory locations.The number of elements is the array&rsquo;s length and it is never negative. The length of the array must always evaluate to a non-negative constant that can be represented as a value of the int data type.</p><p>In Go unlike in other imperative languages the size of the array is part of its type, which in part limits its expressive power hence you will not often use them in your programs. However this is not to say that they are not important for you to understand them.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>    <span style=color:#00f>var</span> ints [5]<span style=color:#2b91af>int</span>

    fmt.Printf(<span style=color:#a31515>&#34;%T\n&#34;</span>, ints) <span style=color:green>//[5]int is the type
</span></code></pre></div><p>The values stored in an array are called elements. These elements are accessed by use of indices <em>(plural for index)</em>. An integer value is used to indicate the ordinal value of the element in the array.<br>For example, if <em>n</em> is an array with 5 elements, then <em>n[5]</em> is the element of <em>n</em> with <strong>ordinal</strong> value 6. Indexing of arrays in Golang much like in other imperative languages starts at 0, thus <em>n[5]</em> is the <em>6th</em> value in <em>n</em>.</p><p>Arrays are important because they allow many values to be stored in a single data structure while providing for very fast access to each value.This is made possible by the fact that:</p><ul><li>All values in an array are of the same type <em>(homogenous)</em> hence they require the same amount of memory to store.</li><li>Elements are stored in contiguous memory locations.</li></ul><p>In Golang the size of an array must be established once and for all when storage for the array is allocated and cannot change thereafter.Therefore in go arrays are fixed.i.e an array in go must have its size specified as a constant in its declaration and this size cannot change during execution.</p><p>Arrays in Go are just values. An array variable denotes an entire array hence when you pass an array as an argument to a function, a copy of the original&rsquo;s contents is passed in. Therefore modifying its contents does not modify the contents of the original. To do that you must pass a pointer to the array variable.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>    <span style=color:#00f>func</span> mod(ints *[5]<span style=color:#2b91af>int</span>){
        <span style=color:green>//do some modification here
</span><span style=color:green></span>    }

    <span style=color:green>//declare an zero value array of ints.
</span><span style=color:green></span>    <span style=color:#00f>var</span> numbers [5]<span style=color:#2b91af>int</span>

    <span style=color:green>//Then we call mod like this
</span><span style=color:green></span>    mod(&amp;numbers)
</code></pre></div><h3 id=how-to-declare-an-array>How to declare an array</h3><p>Go has several ways of declaring arrays. You can use one of the two ways shown below to declare an array in Go.</p><ul><li>Using var keyword</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>    <span style=color:#00f>var</span> identifier [size]T <span style=color:green>//declaration syntax. T  represents type.
</span><span style=color:green></span>    
    <span style=color:#00f>var</span> ints [5]<span style=color:#2b91af>int</span>
</code></pre></div><ul><li>Using short assignment</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>    identifier := expression <span style=color:green>//declaration syntax
</span><span style=color:green></span>
    ints := [5]<span style=color:#2b91af>int</span>{}

    <span style=color:green>//or
</span><span style=color:green></span>
    ints := [...]<span style=color:#2b91af>int</span>{} <span style=color:green>//the compiler will compute the length at runtime.
</span></code></pre></div><h3 id=how-to-initialize-an-array>How to initialize an array</h3><p>Now you know how to declare an array variable in golang. How about to initialize it? Golang is nothing like other programming languages where the default value of uninitialized variables is <em>Null</em>, <em>nil</em>, <em>None</em> or even <em>Undefined</em>. Instead in Go variables are initialized to the zero value of their declared type. That is to mean if your variable holds an int then it will be initialized to <em>0</em> and thus ready to use. You wont get some of the issues you get with using uninitialized variables as is in Java and the rest. :-)</p><p>To initialize the array to your predefined values you could use one of two ways.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>    <span style=color:#00f>var</span> ints [5]<span style=color:#2b91af>int</span> = [5]<span style=color:#2b91af>int</span>{1,2,3,4,5}
</code></pre></div><p>or</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>    ints :=[5]<span style=color:#2b91af>int</span>{1,2,3,4,5}
</code></pre></div><h3 id=accessing-elements-in-arrays>Accessing elements in Arrays</h3><p>To access the individual elements in an array Go provides convenient ways by use of the <em>for</em> and <em>for range</em> loops.</p><p>For example given the following array.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>num := [5]<span style=color:#2b91af>int</span>{1,2,3,4,5}

<span style=color:#00f>for</span> i := 0; i &lt; len(num); i++ {
    fmt.Printf(<span style=color:#a31515>&#34;%v\n&#34;</span>,num[i])
}
</code></pre></div><p>or</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>num := [5]<span style=color:#2b91af>int</span>{1,2,3,4,5}

<span style=color:#00f>for</span> _,v := <span style=color:#00f>range</span> num{
    fmt.Printf(<span style=color:#a31515>&#34;%v\n&#34;</span>,v)
}
</code></pre></div><p>When an array of a given size, say N and of a given type T, the compiler allocates enough memory to hold all N pieces of data.
If M bytes of memory is required for each piece of data of the type T, then a total of N*M bytes of contiguous memory are allocated to that array variable.</p><p>The data for the first element is stored in the first M bytes, the data for the second element is stored in the next M bytes and so on and so forth.The Go compiler remembers the address of the first byte of an array only. In fact the address of the first byte is considered the memory address for the entire array.Thus knowing the address of the first byte the compiler can easily find the memory address for any other element of the array using the below formula.</p><blockquote><p>b + ( i * m )</p></blockquote><p>where</p><blockquote><p><strong>b</strong> is the base address <em>( address of the first byte of the array )</em> , <strong>i</strong> is the position of the element. i.e the <em>ordinal value</em> , <strong>m</strong> is the size of an array element of <em>type T</em></p></blockquote><p>The summation <em>( i + m )</em> is called the <strong>offset</strong>.</p><p>For example given an array A, to retrieve the data stored in A[n], the computer goes to the address of the array ( b ) then increments it by the offset <em>(n * M)</em> and retrieves the next M bytes of data.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>  <span style=color:#00f>package</span> main

  <span style=color:#00f>import</span> (
      <span style=color:#a31515>&#34;fmt&#34;</span>
      <span style=color:#a31515>&#34;unsafe&#34;</span>
  )

  <span style=color:#00f>func</span> main() {
      ints := [5]<span style=color:#2b91af>int</span>{1, 4, 5, 8, 9}

      fmt.Printf(<span style=color:#a31515>&#34;Address of the int variable %p\n&#34;</span>, &amp;ints)
      fmt.Printf(<span style=color:#a31515>&#34;Index\tValue\tAddress\n&#34;</span>)
      <span style=color:#00f>for</span> i := 0; i &lt; len(ints); i++ {
          pint := unsafe.Pointer(&amp;ints[i])
          fmt.Printf(<span style=color:#a31515>&#34;%d\t\t\t%v\t\t\t%v\n&#34;</span>, i, ints[i], pint)
      }

  }
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span>$</span> <span style=color:#00f>go</span> run array.<span style=color:#00f>go</span>
Address of the ints variable 0xc0000b4060
Index	Value	Address
0		1		0xc0000b4060
1		4		0xc0000b4068
2		5		0xc0000b4070
3		8		0xc0000b4078
4		9		0xc0000b4080
</code></pre></div><p>The above code snippet declares and initializes an array literal using the short hand declaration style and afterwards iterates through each of its elements printing out their addresses. Note that the address of the <em>ints</em> variable is the same as of the first element in the array ( <em>ints[0]</em> ).</p><p>Also note that the above elements are aligned using a 8 byte alignment in the contiguous memory location. That means each element in the array occupies 8 bytes which is equivalent to 64 bits, which is the default size of an int in a 64 bit machine.( <em>I am using a 64 bit machine</em> ). Therefore if we were to find out the location of the 5th element <em>(index 4 )</em> in the array, we would only need to know the base address of the array which is <em>0xc0000b4060</em>. Then we would use the above formula to compute the address.</p><blockquote><p>formulae: base_address + offset<br>base_address = 0xc0000b4060<br>offset = (i * m) = 4 * 8 = 32 (decimal)<br>convert it to hexadecimal 32 = 0x20<br>0xc0000b4060 + 0x20 = 0xc0000b4080</p></blockquote><p><strong>Note</strong></p><p><em>Details about how elements are stored in contiguous locations varies somewhat among languages. Do not generalize the information above.</em></p><h3 id=references>References</h3><ul><li><a href=https://golang.org/ref/spec>Golang Reference Specification</a></li><li><a href=https://blog.golang.org/>The Go Programming Language Blog</a></li><li><a href=https://github.com/golang/go>The Go source code</a></li></ul></div><div class=tags></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='ink-demo';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the</a></noscript><a href=http://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><div class="footer wrapper"><nav class=nav><div>2019 © Copyright notice |
<a href=https://gohugo.io>Powered by Hugo</a></div></nav></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-123-45','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></body></html>